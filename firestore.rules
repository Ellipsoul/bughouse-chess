rules_version = '2';

/**
 * Firestore Security Rules for Bughouse Chess.
 *
 * These rules define access control for the database.
 *
 * Key design decisions:
 * - Usernames are permanent and cannot be changed or deleted
 * - Users can only create their own user document
 * - All writes require authentication
 * - Shared games are publicly readable but only writable by fully-authenticated users
 *
 * Note: The emulator does not enforce these rules by default.
 * To test with rules, start emulator with: firebase emulators:start --only firestore
 *
 * @see https://firebase.google.com/docs/firestore/security/get-started
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if the user owns this resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to validate username format
    // Username must be 3-20 characters, lowercase, alphanumeric + underscores
    function isValidUsername(username) {
      return username.size() >= 3
             && username.size() <= 20
             && username.matches('^[a-z0-9_]+$');
    }

    // Helper function to check if user has reserved a username (fully authenticated)
    // This requires the user document to exist with a username field
    function isFullyAuthenticated() {
      return isAuthenticated()
             && exists(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    // Helper function to validate shared game description length
    function isValidDescription(description) {
      return description is string && description.size() <= 100;
    }

    // Helper function to validate shared game type
    function isValidSharedGameType(type) {
      return type == 'game' || type == 'match' || type == 'partnerGames';
    }

    /**
     * Usernames collection.
     *
     * Document ID: normalized username (lowercase)
     * Document fields:
     *   - userId: string (Firebase Auth UID of the owner)
     *   - createdAt: timestamp (server timestamp)
     */
    match /usernames/{username} {
      // Authenticated users can check if a username exists (for availability checking)
      allow read: if isAuthenticated();

      // Only allow creation with strict validation:
      // 1. User is authenticated
      // 2. The userId field matches the authenticated user
      // 3. The username format is valid
      // 4. Required fields are present with correct types
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && isValidUsername(username)
                    && request.resource.data.keys().hasAll(['userId', 'createdAt'])
                    && request.resource.data.userId is string
                    && request.resource.data.createdAt == request.time;

      // Never allow updates or deletes (usernames are permanent)
      allow update, delete: if false;
    }

    /**
     * Users collection.
     *
     * Document ID: Firebase Auth UID
     * Document fields:
     *   - username: string (the user's chosen username, lowercase)
     *   - createdAt: timestamp (server timestamp)
     */
    match /users/{userId} {
      // Users can only read their own document
      allow read: if isOwner(userId);

      // Only allow creation with strict validation:
      // 1. User owns this document (userId matches their auth UID)
      // 2. Required fields are present with correct types
      // 3. Username format is valid
      allow create: if isOwner(userId)
                    && request.resource.data.keys().hasAll(['username', 'createdAt'])
                    && request.resource.data.username is string
                    && isValidUsername(request.resource.data.username)
                    && request.resource.data.createdAt == request.time;

      // Never allow updates or deletes (username is permanent)
      allow update, delete: if false;

      /**
       * User's shared games subcollection.
       *
       * Document ID: shared game UUID (matches document in sharedGames collection)
       * Document fields:
       *   - sharedId: string (reference to sharedGames document)
       *   - sharedAt: timestamp
       */
      match /sharedGames/{sharedId} {
        // Users can only read their own shared games references
        allow read: if isOwner(userId);

        // Users can create references to their own shared games
        allow create: if isOwner(userId)
                      && request.resource.data.keys().hasAll(['sharedId', 'sharedAt'])
                      && request.resource.data.sharedId is string
                      && request.resource.data.sharedId == sharedId;

        // Users can delete their own shared game references
        allow delete: if isOwner(userId);

        // Never allow updates (references are immutable)
        allow update: if false;
      }
    }

    /**
     * Shared games collection.
     *
     * Document ID: UUID
     * Document fields:
     *   - id: string (same as document ID)
     *   - schemaVersion: number (always 2)
     *   - type: 'game' | 'match' | 'partnerGames'
     *   - sharerUserId: string (Firebase Auth UID)
     *   - sharerUsername: string
     *   - description: string (max 100 chars)
     *   - sharedAt: timestamp
     *   - gameDate: timestamp
     *   - metadata: object (players, result, gameCount)
     *
     * Game data is stored in subcollection: games/{index}
     */
    match /sharedGames/{sharedId} {
      // Anyone can read shared games (public browsing, no auth required)
      allow read: if true;

      // Only fully authenticated users can share games
      // Game data is stored in subcollection, not in main document
      allow create: if isFullyAuthenticated()
                    && request.resource.data.sharerUserId == request.auth.uid
                    && request.resource.data.keys().hasAll([
                         'id', 'schemaVersion', 'type', 'sharerUserId', 'sharerUsername',
                         'description', 'sharedAt', 'gameDate', 'metadata'
                       ])
                    && request.resource.data.id == sharedId
                    && request.resource.data.schemaVersion == 2
                    && isValidSharedGameType(request.resource.data.type)
                    && isValidDescription(request.resource.data.description)
                    && request.resource.data.sharerUserId is string
                    && request.resource.data.sharerUsername is string;

      // Only the original sharer can delete their shared game
      allow delete: if isAuthenticated()
                    && resource.data.sharerUserId == request.auth.uid;

      // Updates are not allowed (shared games are immutable)
      allow update: if false;

      /**
       * Games subcollection.
       *
       * Document ID: index (0, 1, 2, ...)
       * Document fields:
       *   - index: number (same as document ID)
       *   - type: 'single' | 'match'
       *   - data: object (SingleGameData or MatchGameData)
       *
       * This subcollection stores the actual game data to avoid the 1MB document limit.
       *
       * Note: We cannot use get() to check parent document ownership on create because
       * batch writes evaluate rules before any documents are written. The parent document
       * and subcollection documents are created in the same batch, so get() would fail.
       * Security is maintained because the batch is atomic - if parent creation fails
       * validation, the whole batch fails.
       */
      match /games/{gameIndex} {
        // Anyone can read game data (public)
        allow read: if true;

        // Only fully authenticated users can create game data
        // The parent document validation (in the same batch) ensures proper ownership
        allow create: if isFullyAuthenticated()
                      && request.resource.data.keys().hasAll(['index', 'type', 'data'])
                      && request.resource.data.index is number;

        // Only the sharer can delete game data
        // For delete, the parent document already exists so get() works
        allow delete: if isAuthenticated()
                      && get(/databases/$(database)/documents/sharedGames/$(sharedId)).data.sharerUserId == request.auth.uid;

        // Never allow updates (game data is immutable)
        allow update: if false;
      }
    }

    // Deny access to all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
